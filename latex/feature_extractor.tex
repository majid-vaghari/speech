
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{feature\_extractor}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Feature Extractor}\label{feature-extractor}

This is a helper module which defines some functions to extract features
from a given audio file.

Each function has a little desctiption above it and also is described in
its own docstring.

Module docstring and imports:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{This module is made to extract features from a given audio file.}
        \PY{l+s+sd}{You can also extract them manually using helper functions in here.}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\end{Verbatim}


    \subsection{Extract frames}\label{extract-frames}

To extract features from an audio file the first step is to extract
frames.

This function gets a signal (array of integers that show intensity at
that sample), and returns a list of frames with given step size and
frame length. note that the output frames will overlap and the amount of
samples which they overlap is \texttt{frame\_length} - \texttt{step}.

This function is not exported because it will be used in the next
function.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k}{def} \PY{n+nf}{\PYZus{}get\PYZus{}frames}\PY{p}{(}\PY{n}{signal}\PY{p}{,} \PY{n}{step}\PY{p}{,} \PY{n}{frame\PYZus{}length}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function is used to divide a given signal into}
        \PY{l+s+sd}{    frames with given length and given step size.}
        \PY{l+s+sd}{    This also appends a zero frame to the end of frames.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    signal : array\PYZus{}like}
        \PY{l+s+sd}{        this is the signal that will be divided}
        \PY{l+s+sd}{        into multiple frames.}
        \PY{l+s+sd}{    step : int}
        \PY{l+s+sd}{        this specifies the step size i.e. the number of}
        \PY{l+s+sd}{        samples between start points of two}
        \PY{l+s+sd}{        consecutive frames.}
        \PY{l+s+sd}{    frame\PYZus{}length : int}
        \PY{l+s+sd}{        length of each frame i.e. the number of}
        \PY{l+s+sd}{        samples in each frame.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    list}
        \PY{l+s+sd}{        list of frames.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{n}{max\PYZus{}start} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{signal}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{frame\PYZus{}length}\PY{p}{)} \PY{o}{/} \PY{n}{step}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1}
            \PY{n}{window} \PY{o}{=} \PY{p}{[}\PY{n}{signal}\PY{p}{[}\PY{n}{i} \PY{o}{*} \PY{n}{step}\PY{p}{:}\PY{n}{i} \PY{o}{*} \PY{n}{step} \PY{o}{+} \PY{n}{frame\PYZus{}length}\PY{p}{]}
                      \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{max\PYZus{}start}\PY{p}{)}\PY{p}{]}
            \PY{n}{last} \PY{o}{=} \PY{n}{signal}\PY{p}{[}\PY{n}{max\PYZus{}start} \PY{o}{*} \PY{n}{step}\PY{p}{:}\PY{p}{]}
            \PY{n}{window}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{pad}\PY{p}{(}
                \PY{n}{last}\PY{p}{,}
                \PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{frame\PYZus{}length} \PY{o}{\PYZhy{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{last}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{constant}\PY{l+s+s1}{\PYZsq{}}
            \PY{p}{)}\PY{p}{)}
            \PY{n}{window}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{frame\PYZus{}length}\PY{p}{)}\PY{p}{)}
            
            \PY{k}{return} \PY{n}{window}
\end{Verbatim}


    Next functions is used to get frames from a given file. It uses the
previously defined function and gets input in seconds rather than number
of samples (which depends on sampling rate).

This function is exported.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k}{def} \PY{n+nf}{get\PYZus{}frames\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{,}
                                 \PY{n}{step}\PY{o}{=}\PY{l+m+mf}{0.01}\PY{p}{,}
                                 \PY{n}{frame\PYZus{}length}\PY{o}{=}\PY{l+m+mf}{0.025}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function extracts frames from a given file.}
        \PY{l+s+sd}{    Uses scipy to read wav file.}
        \PY{l+s+sd}{    This function also adds a zero frame to the}
        \PY{l+s+sd}{    end of file and applys hamming window to all frames.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    filename : string}
        \PY{l+s+sd}{        name of the audio file.}
        \PY{l+s+sd}{    step : float}
        \PY{l+s+sd}{        step size in seconds i.e. the difference between}
        \PY{l+s+sd}{        start points of two consecutive frames}
        \PY{l+s+sd}{        in seconds (default: 10 ms).}
        \PY{l+s+sd}{    frame\PYZus{}length : float}
        \PY{l+s+sd}{        length of each frame in seconds (default: 25 ms).}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    list}
        \PY{l+s+sd}{        list of frames.}
        \PY{l+s+sd}{    int}
        \PY{l+s+sd}{        sampling rate of the input file.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{k+kn}{import} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{io}\PY{n+nn}{.}\PY{n+nn}{wavfile}
            \PY{c+c1}{\PYZsh{} read file}
            \PY{p}{[}\PY{n}{fs}\PY{p}{,} \PY{n}{y}\PY{p}{]} \PY{o}{=} \PY{n}{scipy}\PY{o}{.}\PY{n}{io}\PY{o}{.}\PY{n}{wavfile}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{n}{filename}\PY{p}{)}
            \PY{c+c1}{\PYZsh{} divide the signal to frames and apply}
            \PY{c+c1}{\PYZsh{} the hamming window function on them}
            \PY{n}{frames} \PY{o}{=} \PY{p}{[}\PY{p}{]}
            \PY{k}{for} \PY{n}{f} \PY{o+ow}{in} \PY{n}{\PYZus{}get\PYZus{}frames}\PY{p}{(}\PY{n}{y}\PY{p}{,} \PY{n+nb}{int}\PY{p}{(}\PY{n}{fs} \PY{o}{*} \PY{n}{step}\PY{p}{)}\PY{p}{,} \PY{n+nb}{int}\PY{p}{(}\PY{n}{fs} \PY{o}{*} \PY{n}{frame\PYZus{}length}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                \PY{n}{frames}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{f} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{hamming}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{f}\PY{p}{)}\PY{p}{)}\PY{p}{)}
            \PY{k}{return} \PY{n}{frames}\PY{p}{,} \PY{n}{fs}
\end{Verbatim}


    Now we define some helper functions to convert Mels to Hertz and vice
versa.

To convert from frequency to Mel:

\[ M(f) = 1125\ln\left(1+\frac{f}{700}\right) \]

And to convert from Mel to frequency:

\[ M^{-1}(m) = 700 \times \left(e^{\frac{m}{1125}} - 1\right) \]

These functions are not exported because they will be used in the next
function

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k}{def} \PY{n+nf}{\PYZus{}hz2mel}\PY{p}{(}\PY{n}{hz}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function converts frequency to Mel scale.}
        \PY{l+s+sd}{    Supports numpy arrays.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    hz : \PYZob{}float, array\PYZus{}like\PYZcb{}}
        \PY{l+s+sd}{        input(s) in hertz.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    \PYZob{}float, array\PYZus{}like\PYZcb{}}
        \PY{l+s+sd}{        converted value of input.}
        \PY{l+s+sd}{        If input was array will return an array of same size.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{k}{return} \PY{l+m+mi}{1125} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{log}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{+} \PY{p}{(}\PY{n}{hz} \PY{o}{/} \PY{l+m+mf}{700.}\PY{p}{)}\PY{p}{)}
        
        \PY{k}{def} \PY{n+nf}{\PYZus{}mel2hz}\PY{p}{(}\PY{n}{mel}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function converts Mel scale to frequency.}
        \PY{l+s+sd}{    Supports numpy arrays.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    hz : \PYZob{}float, array\PYZus{}like\PYZcb{}}
        \PY{l+s+sd}{        input(s) in Mel scale.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    \PYZob{}float, array\PYZus{}like\PYZcb{}}
        \PY{l+s+sd}{        converted value of input.}
        \PY{l+s+sd}{        If input was array will return an array of same size.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{k}{return} \PY{l+m+mi}{700} \PY{o}{*} \PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{e} \PY{o}{*}\PY{o}{*} \PY{p}{(}\PY{n}{mel} \PY{o}{/} \PY{l+m+mf}{1125.}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


    This function is used to calculate Mel filter banks. To compute the
filter bank: 1. Pick some low and high frequencies (we choose 300Hz and
8KHz). 2. Calculate Mel points (we choose to calculate 26 of them). 3.
Convert Mels back to Hertz. 4. Round the resulting points (called Mel
pints). 5. Create the filterbanks.The first filterbank will start at the
first point, reach its peak at the second point, then return to zero at
the 3rd point. The second filterbank will start at the 2nd point, reach
its max at the 3rd, then be zero at the 4th etc. A formula for
calculating these is as follows:

\[
     H_m(k) = 
    \begin{cases} 
        0                                & k < f(m-1) \\
        \frac{k - f(m-1)}{f(m) - f(m-1)} & f(m-1) \leq k \leq f(m) \\
        \frac{f(m+1) - k}{f(m+1) - f(m)} & f(m) \leq k \leq f(m+1) \\
        0                                & k > f(m+1)
    \end{cases}
 \]

where \$ M \$ is the number of filters we want, and \$ f \$ is the list
of \$ M + 2 \$ Mel-spaced frequencies.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k}{def} \PY{n+nf}{get\PYZus{}mel\PYZus{}filterbanks}\PY{p}{(}\PY{n}{n}\PY{o}{=}\PY{l+m+mi}{26}\PY{p}{,}
                                \PY{n}{nfft}\PY{o}{=}\PY{l+m+mi}{512}\PY{p}{,}
                                \PY{n}{samplerate}\PY{o}{=}\PY{l+m+mi}{16000}\PY{p}{,}
                                \PY{n}{low\PYZus{}frequency}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{,}
                                \PY{n}{high\PYZus{}frequency}\PY{o}{=}\PY{l+m+mi}{8000}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{} step 1}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    Calculates Mel filter banks.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    n : int}
        \PY{l+s+sd}{        number of filterbanks returned.}
        \PY{l+s+sd}{    nfft : int}
        \PY{l+s+sd}{        lenghth of fft output.}
        \PY{l+s+sd}{    samplerate : int}
        \PY{l+s+sd}{        sampling rate of the audio file}
        \PY{l+s+sd}{        (default 16 KHz).}
        \PY{l+s+sd}{    low\PYZus{}frequency : int}
        \PY{l+s+sd}{        starting frequency for filterbanks}
        \PY{l+s+sd}{        (default 300).}
        \PY{l+s+sd}{    high\PYZus{}frequency : int}
        \PY{l+s+sd}{        high frequency for filter banks.}
        \PY{l+s+sd}{        This can\PYZsq{}t be more than samplerates / 2.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    list}
        \PY{l+s+sd}{        list of Mel filter banks.}
        \PY{l+s+sd}{        length of this list is n (the first parameter).}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{k}{if} \PY{n}{high\PYZus{}frequency} \PY{o}{\PYZgt{}} \PY{n}{samplerate} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{2}\PY{p}{:}
                \PY{n}{high\PYZus{}frequency} \PY{o}{=} \PY{n}{samplerate} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{2}
            
            \PY{n}{mel} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}
                \PY{n}{\PYZus{}hz2mel}\PY{p}{(}\PY{n}{low\PYZus{}frequency}\PY{p}{)}\PY{p}{,}
                \PY{n}{\PYZus{}hz2mel}\PY{p}{(}\PY{n}{high\PYZus{}frequency}\PY{p}{)}\PY{p}{,}
                \PY{n}{n} \PY{o}{+} \PY{l+m+mi}{2}
            \PY{p}{)} \PY{c+c1}{\PYZsh{} step 2}
            \PY{n}{hertz} \PY{o}{=} \PY{n}{\PYZus{}mel2hz}\PY{p}{(}\PY{n}{mel}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 3}
            \PY{n}{fftbin} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{p}{(}\PY{n}{nfft} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{*} \PY{n}{hertz} \PY{o}{/} \PY{n}{samplerate}\PY{p}{)}
                        \PY{o}{.}\PY{n}{astype}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{int64}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 4}
        
            \PY{n}{fbank} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{[}\PY{n}{n}\PY{p}{,} \PY{p}{(}\PY{n}{nfft} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 5}
            \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
                \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{fftbin}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{,} \PY{n}{fftbin}\PY{p}{[}\PY{n}{j}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{:}
                    \PY{n}{fbank}\PY{p}{[}\PY{n}{j}\PY{p}{,} \PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{fftbin}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{)} \PY{o}{/}
                                \PY{p}{(}\PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{fftbin}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{)}
                \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{:}
                    \PY{n}{fbank}\PY{p}{[}\PY{n}{j}\PY{p}{,} \PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{2}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{i}\PY{p}{)} \PY{o}{/}
                                \PY{p}{(}\PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{2}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{fftbin}\PY{p}{[}\PY{n}{j} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
            
            \PY{k}{return} \PY{n}{fbank}
\end{Verbatim}


    Now, we take a glimpse at the steps to compute MFCCs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Frame the signal into short frames (already done).
\item
  For each frame calculate the periodogram estimate of the power
  spectrum.
\end{enumerate}

Suppose that we show our original signal of frame \$ i \$ with notation
\$ s\_i(n) \$ (n being the number of sample). When we calculate the
complex DFT we get \$ S\_i(k) \$.

\[ S_i(k) = \sum_{n=1}^{N} s_i(n)h(n)e^{\frac{-j2\pi kn}{N}} \]

where \$ h(n) \$ is an \$ N \$ sample long analysis window (e.g. hamming
window), and \$ K \$ is the length of the DFT. The periodogram-based
power spectral estimate for the speech frame \$ s\_i(n) \$ is given by:

\[ P_i(k) = \frac{1}{N}\left\lvert S_i(k) \right\rvert^2 \]

This is called the Periodogram estimate of the power spectrum. We take
the absolute value of the complex fourier transform, and square the
result. We would generally perform a 512 point FFT and keep only the
first 257 coefficents. 3. Apply the Mel filterbank to the power spectra,
sum the energy in each filter. 4. Take the logarithm of all filterbank
energies. 5. Take the DCT of the log filterbank energies. 6. Keep DCT
coefficients 2-13, discard the rest. 7. Calculate frame energy. To do
that, simply sum the power spectrum (because power spectrum is actually
energy of the signal in different frequencies).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k}{def} \PY{n+nf}{mfcc}\PY{p}{(}\PY{n}{signal}\PY{p}{,}
                 \PY{n}{nfft}\PY{o}{=}\PY{l+m+mi}{512}\PY{p}{,}
                 \PY{n}{samplerate}\PY{o}{=}\PY{l+m+mi}{16000}\PY{p}{,}
                 \PY{n}{nfilt}\PY{o}{=}\PY{l+m+mi}{26}\PY{p}{,}
                 \PY{n}{mel\PYZus{}low}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{,}
                 \PY{n}{mel\PYZus{}high}\PY{o}{=}\PY{l+m+mi}{8000}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function extracts Mel frequency cepstral}
        \PY{l+s+sd}{    coefficients from the given signal.}
        \PY{l+s+sd}{    This signal must be a list of extracted frames.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    signal : array\PYZus{}like}
        \PY{l+s+sd}{        array of frames (each frame is an array itself).}
        \PY{l+s+sd}{    nfft : int}
        \PY{l+s+sd}{        number of fft output (default 512).}
        \PY{l+s+sd}{    samplerate : int}
        \PY{l+s+sd}{        sampling rate of input signal (default 16000).}
        \PY{l+s+sd}{    nfilt : int}
        \PY{l+s+sd}{        number of filters in Mel filter banks}
        \PY{l+s+sd}{        (default 26).}
        \PY{l+s+sd}{    mel\PYZus{}low : int}
        \PY{l+s+sd}{        starting frequency of Mel filter banks}
        \PY{l+s+sd}{        (default 300 Hz).}
        \PY{l+s+sd}{    mel\PYZus{}high : int}
        \PY{l+s+sd}{        high frequency of Mel filter banks (default 8 KHz).}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    array}
        \PY{l+s+sd}{        returns an array of extracted features.}
        \PY{l+s+sd}{        Length of array is the same as length of}
        \PY{l+s+sd}{        input (number of frames).}
        \PY{l+s+sd}{        Each feature vector consists of 12 MFCCs}
        \PY{l+s+sd}{        and energy of that frame. So each feature}
        \PY{l+s+sd}{        vector is of length 13.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{fftpack} \PY{k}{import} \PY{n}{dct}
            \PY{c+c1}{\PYZsh{} already multiplied signal by hamming window}
            \PY{c+c1}{\PYZsh{} so all we need to to do is to call fft}
            \PY{n}{magspec} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{absolute}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{fft}\PY{o}{.}\PY{n}{rfft}\PY{p}{(}\PY{n}{signal}\PY{p}{,} \PY{n}{nfft}\PY{p}{)}\PY{p}{)}
            \PY{n}{powspec} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.} \PY{o}{/} \PY{n+nb}{len}\PY{p}{(}\PY{n}{signal}\PY{p}{)}\PY{p}{)} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{square}\PY{p}{(}\PY{n}{magspec}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 2}
            
            \PY{n}{fbank} \PY{o}{=} \PY{n}{get\PYZus{}mel\PYZus{}filterbanks}\PY{p}{(}\PY{n}{nfilt}\PY{p}{,}
                                        \PY{n}{nfft}\PY{p}{,}
                                        \PY{n}{samplerate}\PY{p}{,}
                                        \PY{n}{mel\PYZus{}low}\PY{p}{,}
                                        \PY{n}{mel\PYZus{}high}\PY{p}{)}
            
            \PY{n}{ft} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{powspec}\PY{p}{,} \PY{n}{fbank}\PY{o}{.}\PY{n}{T}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 3}
            \PY{c+c1}{\PYZsh{} if ft is zero, we get problems with log}
            \PY{n}{ft} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{ft} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{finfo}\PY{p}{(}\PY{n+nb}{float}\PY{p}{)}\PY{o}{.}\PY{n}{eps}\PY{p}{,} \PY{n}{ft}\PY{p}{)}
            
            \PY{n}{ft} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{log}\PY{p}{(}\PY{n}{ft}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 4}
            
            \PY{n}{ft} \PY{o}{=} \PY{n}{dct}\PY{p}{(}\PY{n}{ft}\PY{p}{,} \PY{n}{norm}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ortho}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{p}{:}\PY{l+m+mi}{12}\PY{p}{]} \PY{c+c1}{\PYZsh{} steps 5 and 6}
            
            \PY{n}{energy} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{powspec}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} step 7}
            \PY{c+c1}{\PYZsh{} if energy is zero, we get problems with log}
            \PY{n}{energy} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{energy} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{finfo}\PY{p}{(}\PY{n+nb}{float}\PY{p}{)}\PY{o}{.}\PY{n}{eps}\PY{p}{,}\PY{n}{energy}\PY{p}{)}
            
            \PY{n}{ft} \PY{o}{=} \PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{ft}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{energy}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{energy}\PY{p}{)}\PY{p}{)}\PY{p}{]}
            
            \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{ft}\PY{p}{)}
\end{Verbatim}


    For simplicity, we define yet another function that gets a filename and
extracts features and returns them. This is used in the end, when we
want to test our ASR.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k}{def} \PY{n+nf}{extract}\PY{p}{(}\PY{n}{filename}\PY{p}{,}
                    \PY{n}{frame\PYZus{}step}\PY{o}{=}\PY{l+m+mf}{0.01}\PY{p}{,}
                    \PY{n}{frame\PYZus{}length}\PY{o}{=}\PY{l+m+mf}{0.025}\PY{p}{,}
                    \PY{n}{nfft}\PY{o}{=}\PY{l+m+mi}{512}\PY{p}{,}
                    \PY{n}{nfilt}\PY{o}{=}\PY{l+m+mi}{26}\PY{p}{,}
                    \PY{n}{mel\PYZus{}low}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{,}
                    \PY{n}{mel\PYZus{}high}\PY{o}{=}\PY{l+m+mi}{8000}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{l+s+sd}{    This function extracts Mel frequency}
        \PY{l+s+sd}{    cepstral coefficients from the given signal.}
        \PY{l+s+sd}{    This signal must be a list of extracted frames.}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Parameters}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    filename : string}
        \PY{l+s+sd}{        name of the file.}
        \PY{l+s+sd}{    frame\PYZus{}step : float}
        \PY{l+s+sd}{        step size in seconds i.e. the difference between}
        \PY{l+s+sd}{        start points of two consecutive frames in seconds}
        \PY{l+s+sd}{        (default: 10 ms).}
        \PY{l+s+sd}{    frame\PYZus{}length : float}
        \PY{l+s+sd}{        length of each frame in seconds (default: 25 ms).}
        \PY{l+s+sd}{    nfft : int}
        \PY{l+s+sd}{        number of fft output (default 512).}
        \PY{l+s+sd}{    nfilt : int}
        \PY{l+s+sd}{        number of filters in Mel filter banks (default 26).}
        \PY{l+s+sd}{    mel\PYZus{}low : int}
        \PY{l+s+sd}{        starting frequency of Mel filter banks}
        \PY{l+s+sd}{        (default 300 Hz).}
        \PY{l+s+sd}{    mel\PYZus{}high : int}
        \PY{l+s+sd}{        high frequency of Mel filter banks (default 8 KHz).}
        \PY{l+s+sd}{    }
        \PY{l+s+sd}{    Returns}
        \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
        \PY{l+s+sd}{    array}
        \PY{l+s+sd}{        returns an array of extracted features.}
        \PY{l+s+sd}{        Length of array is the the number of}
        \PY{l+s+sd}{        frame in input file.}
        \PY{l+s+sd}{        Each feature vector consists of 12 MFCCs}
        \PY{l+s+sd}{        and energy of that frame. So each feature}
        \PY{l+s+sd}{        vector is of length 13.}
        \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{n}{signal} \PY{o}{=} \PY{n}{get\PYZus{}frames\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{,}
                                          \PY{n}{frame\PYZus{}step}\PY{p}{,}
                                          \PY{n}{frame\PYZus{}length}\PY{p}{)}
            \PY{k}{return} \PY{n}{mfcc}\PY{p}{(}\PY{n}{signal}\PY{p}{,} \PY{n}{nfft}\PY{p}{,} \PY{n}{nfilt}\PY{p}{,} \PY{n}{mel\PYZus{}low}\PY{p}{,} \PY{n}{mel\PYZus{}high}\PY{p}{)}
\end{Verbatim}



    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
